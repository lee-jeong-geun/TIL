MySQL의 쿼리를 최적으로 실행 하도록 계획을 수립하는게 옵티마이저다.
실행 계획을 통해서 확인하자.

쿼리 실행 절차.
1. 주어진 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해 가능하도록 분리(파스 트리)한다.
2. SQL의 파싱 정보를 확인하면서 어떻게 실행할지(어떤 테이블 읽고 어떤 인덱스 선택할지) 선택한다.
3. 2번에서 결정된 실행을 통해 스토리지 엔진으로부터 데이터 가져온다.

2번 단계에서 다음과 같은 내용 처리
1. 불필요한 조건 제거 및 연산의 단순화
2. 여러 테이블의 조인 순서를 선택
--> 순서에 따라서 걸러지는 데이터 차이가 큼
3. 각 테이블에 사용된 조건과 통계정보를 활용해 인덱스 선택
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
5. 그 외에 더 있음

옵티 마이저 종류
1. 비용 기반 최적화
--> 쿼리를 처리하기 위한 여러 가지 방법을 만들고 각 방법의 비용을 계산해서 선택, 통계 정보 활용함
2. 규칙 기반 최적화
--> 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립. 휴리스틱하기 때문에 잘 안씀

풀 테이블 스캔하는 주된 이유
1. 레코드 건수 자체가 너무 작아서 인덱스 읽는 것보다 풀 테이블 스캔하는게 더 빠른 경우(테이블이 1개의 페이지로 구성된 경우)
--> 세컨더리 인덱스 -> 클러스터드 인덱스 -> 테이블 접근 보다   해당 페이지 1개를 바로 읽는게 훨씬 빠름.
2. where, on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
3. 인덱스 레인지 스캔 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)



InnoDB에서는 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
리드 어헤드 작업이란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 저장함



