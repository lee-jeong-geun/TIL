MySQL의 쿼리를 최적으로 실행 하도록 계획을 수립하는게 옵티마이저다.
실행 계획을 통해서 확인하자.

쿼리 실행 절차.
1. 주어진 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해 가능하도록 분리(파스 트리)한다.
2. SQL의 파싱 정보를 확인하면서 어떻게 실행할지(어떤 테이블 읽고 어떤 인덱스 선택할지) 선택한다.
3. 2번에서 결정된 실행을 통해 스토리지 엔진으로부터 데이터 가져온다.

2번 단계에서 다음과 같은 내용 처리
1. 불필요한 조건 제거 및 연산의 단순화
2. 여러 테이블의 조인 순서를 선택
--> 순서에 따라서 걸러지는 데이터 차이가 큼
3. 각 테이블에 사용된 조건과 통계정보를 활용해 인덱스 선택
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
5. 그 외에 더 있음

옵티 마이저 종류
1. 비용 기반 최적화
--> 쿼리를 처리하기 위한 여러 가지 방법을 만들고 각 방법의 비용을 계산해서 선택, 통계 정보 활용함
2. 규칙 기반 최적화
--> 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립. 휴리스틱하기 때문에 잘 안씀

풀 테이블 스캔하는 주된 이유
1. 레코드 건수 자체가 너무 작아서 인덱스 읽는 것보다 풀 테이블 스캔하는게 더 빠른 경우(테이블이 1개의 페이지로 구성된 경우)
--> 세컨더리 인덱스 -> 클러스터드 인덱스 -> 테이블 접근 보다   해당 페이지 1개를 바로 읽는게 훨씬 빠름.
2. where, on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
3. 인덱스 레인지 스캔 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)



InnoDB에서는 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
리드 어헤드 작업이란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 저장함
캐시 라인 처럼 한 번에 여러개의 페이지를 읽음. 최대 64개.
리드 어헤드는 풀 테이블 스캔에만 사용되는게 아니라 풀 인덱스 스캔에서도 이용됨.


병렬 처리
하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리함.
MySQL 8.0에서는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능.
아무리 병렬 처리 스레드 개수를 늘려도 서버의 CPU 코어 개수를 넘어서면 오히려 성능이 떨어질 수 있음.


ORDER BY 처리(Using filesort)
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
인덱스 장점
insert, update, delete 쿼리 실행시 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름.
인덱스 단점
insert, update, delete 작업 시 부가적인 인덱스 추가/삭제 작업 필요하므로 느림.(B-Tree 특성임)
인덱스 떄문에 디스크 공간 더 많이 필요
--> 당연히 메모리에만 올리고 끝이 아니라 디스크에 저장 후 메모리에 불러오기 떄문에 저장 공간 필요
인덱스의 개수 늘어날수록 버퍼 풀을 위한 메모리 많이 필요.
Filesort 장점
인덱스 생성 안해도 됨. 정렬해야 할 레코드가 많이 않으면 메모리에서 처리 되므로 빠르다.
Filesort 단점
정렬 작업이 쿼리 실행 시 처리되므로 레코드가 많아질수록 느려짐.

소트 버퍼
MySQL은 정렬을 수행하기 위해 별도의 메모리 공간 사용. 이것이 소트 버퍼
버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 변함. 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size의 시스템 변수로 설정 가능.
소트 버퍼를 위한 메모리 공간은 쿼리 실행 완료시 즉시 반납.
레코드 개수가 소트 버퍼의 공간보다 크다면 문제가 생김.
주어진 메모리보다 많은 양의 데이터를 정렬해야 하다보니 디스크를 이용하게 된다. 주어진 레코드를 분할하여 정렬 후 디스크에 기록하고 다시 메모리에 올리고 다시 디스크에 기록하는 방식이다.
--> db 서버에서 많은 작업을 해야하는데 이럴바엔 was에서 정렬을 수행하는 방법은 어떨까?
소트 버퍼를 크게 설정하면 디스크를 덜 사용하니까 정렬 속도가 더 빨라질 것으로 생각할 수 있는데 실제 벤치마크 결과는 큰 차이가 없다.
리눅스 계열의 os에선 너무 큰 sort_buffer_size를 사용할 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.
일반적인 트랜잭션 처리용 소트 버퍼 크기는 56KB ~ 1MB 미만이 적절해 보임.
정렬을 위해 할당되는 소트 버퍼는 세션(로컬, 커넥션) 메모리 영역에 할당됨. 여러 클라이언트가 공유 못함. 정렬 작업이 많은 커넥션이 많아질수록 소트 버퍼로 소비되는 메모리가 많아짐... 운영체제의 메모리
부족 현상이 생길 수 있음.
대량 데이터의 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리 실행 가능.

정렬 알고리즘
레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 싱글 패스, 투 패스로 나뉨(공식 명칭 x)
MySQL 서버의 정렬 방식은 3가지가 있다.
1. <sort_key, rowId> : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬       투 패스 방식
2. <sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 칼럼들은 고정사이즈로 메모리에 저장      싱글 패스 방식
3. <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 칼럼들은 가변 사이즈로 메모리에 저장     싱글 패스 방식

싱글 패스 정렬 방식
select 대상이 되는 컬럼 전부 소트 버퍼에 담았기 때문에 정렬 후 결과를 반환하면 끝.
--> 그냥 구조체 정렬이라 생각하면 됨

투 패스 정렬 방식
정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 넣기 때문에 정렬 후 정렬된 순서대로 프라이머리 키로 테이블을 읽어서 select할 컬럼 가져옴
테이블을 2번 읽어야 하기 때문에 싱글 패스보다 불합리함. 그래도 싱글보단 메모리를 덜 차지하기 때문에 무조건 싱글만 쓰진 않음.
최신 버전에선 일반적으로 싱글 패스 방식 사용.
다음의 경우 싱글 패스 사용 못하고 투 패스 사용
1. 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
2. BLOB, TEXT 타입의 컬럼이 select 대상에 포함될 때
--> 2의 경우 메모리가 매우 크기 때문에 빼고하는게 효율적인듯
싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적
select 쿼리에서 꼭 필요한 컬럼만 조회하는게 아닌 모든 컬럼(*)을 가져오도록 하는 경우가 있는데, 이는 정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용할 가능성 크다.
꼭 필요한 컬럼만 작성하는게 좋음. 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 쿼리에서도 영향을 미친다.
--> 머리속에 잘 새기자















