MySQL의 쿼리를 최적으로 실행 하도록 계획을 수립하는게 옵티마이저다.
실행 계획을 통해서 확인하자.

쿼리 실행 절차.
1. 주어진 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해 가능하도록 분리(파스 트리)한다.
2. SQL의 파싱 정보를 확인하면서 어떻게 실행할지(어떤 테이블 읽고 어떤 인덱스 선택할지) 선택한다.
3. 2번에서 결정된 실행을 통해 스토리지 엔진으로부터 데이터 가져온다.

2번 단계에서 다음과 같은 내용 처리
1. 불필요한 조건 제거 및 연산의 단순화
2. 여러 테이블의 조인 순서를 선택
--> 순서에 따라서 걸러지는 데이터 차이가 큼
3. 각 테이블에 사용된 조건과 통계정보를 활용해 인덱스 선택
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
5. 그 외에 더 있음

옵티 마이저 종류
1. 비용 기반 최적화
--> 쿼리를 처리하기 위한 여러 가지 방법을 만들고 각 방법의 비용을 계산해서 선택, 통계 정보 활용함
2. 규칙 기반 최적화
--> 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립. 휴리스틱하기 때문에 잘 안씀

풀 테이블 스캔하는 주된 이유
1. 레코드 건수 자체가 너무 작아서 인덱스 읽는 것보다 풀 테이블 스캔하는게 더 빠른 경우(테이블이 1개의 페이지로 구성된 경우)
--> 세컨더리 인덱스 -> 클러스터드 인덱스 -> 테이블 접근 보다   해당 페이지 1개를 바로 읽는게 훨씬 빠름.
2. where, on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
3. 인덱스 레인지 스캔 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)



InnoDB에서는 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
리드 어헤드 작업이란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 저장함
캐시 라인 처럼 한 번에 여러개의 페이지를 읽음. 최대 64개.
리드 어헤드는 풀 테이블 스캔에만 사용되는게 아니라 풀 인덱스 스캔에서도 이용됨.


병렬 처리
하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리함.
MySQL 8.0에서는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능.
아무리 병렬 처리 스레드 개수를 늘려도 서버의 CPU 코어 개수를 넘어서면 오히려 성능이 떨어질 수 있음.


ORDER BY 처리(Using filesort)
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
인덱스 장점
insert, update, delete 쿼리 실행시 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름.
인덱스 단점
insert, update, delete 작업 시 부가적인 인덱스 추가/삭제 작업 필요하므로 느림.(B-Tree 특성임)
인덱스 떄문에 디스크 공간 더 많이 필요
--> 당연히 메모리에만 올리고 끝이 아니라 디스크에 저장 후 메모리에 불러오기 떄문에 저장 공간 필요
인덱스의 개수 늘어날수록 버퍼 풀을 위한 메모리 많이 필요.
Filesort 장점
인덱스 생성 안해도 됨. 정렬해야 할 레코드가 많이 않으면 메모리에서 처리 되므로 빠르다.
Filesort 단점
정렬 작업이 쿼리 실행 시 처리되므로 레코드가 많아질수록 느려짐.

소트 버퍼
MySQL은 정렬을 수행하기 위해 별도의 메모리 공간 사용. 이것이 소트 버퍼
버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 변함. 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size의 시스템 변수로 설정 가능.
소트 버퍼를 위한 메모리 공간은 쿼리 실행 완료시 즉시 반납.
레코드 개수가 소트 버퍼의 공간보다 크다면 문제가 생김.
주어진 메모리보다 많은 양의 데이터를 정렬해야 하다보니 디스크를 이용하게 된다. 주어진 레코드를 분할하여 정렬 후 디스크에 기록하고 다시 메모리에 올리고 다시 디스크에 기록하는 방식이다.
--> db 서버에서 많은 작업을 해야하는데 이럴바엔 was에서 정렬을 수행하는 방법은 어떨까?
소트 버퍼를 크게 설정하면 디스크를 덜 사용하니까 정렬 속도가 더 빨라질 것으로 생각할 수 있는데 실제 벤치마크 결과는 큰 차이가 없다.
리눅스 계열의 os에선 너무 큰 sort_buffer_size를 사용할 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.
일반적인 트랜잭션 처리용 소트 버퍼 크기는 56KB ~ 1MB 미만이 적절해 보임.
정렬을 위해 할당되는 소트 버퍼는 세션(로컬, 커넥션) 메모리 영역에 할당됨. 여러 클라이언트가 공유 못함. 정렬 작업이 많은 커넥션이 많아질수록 소트 버퍼로 소비되는 메모리가 많아짐... 운영체제의 메모리
부족 현상이 생길 수 있음.
대량 데이터의 정렬이 필요한 경우 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리 실행 가능.

정렬 알고리즘
레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 싱글 패스, 투 패스로 나뉨(공식 명칭 x)
MySQL 서버의 정렬 방식은 3가지가 있다.
1. <sort_key, rowId> : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬       투 패스 방식
2. <sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 칼럼들은 고정사이즈로 메모리에 저장      싱글 패스 방식
3. <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬, 레코드의 칼럼들은 가변 사이즈로 메모리에 저장     싱글 패스 방식

싱글 패스 정렬 방식
select 대상이 되는 컬럼 전부 소트 버퍼에 담았기 때문에 정렬 후 결과를 반환하면 끝.
--> 그냥 구조체 정렬이라 생각하면 됨

투 패스 정렬 방식
정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 넣기 때문에 정렬 후 정렬된 순서대로 프라이머리 키로 테이블을 읽어서 select할 컬럼 가져옴
테이블을 2번 읽어야 하기 때문에 싱글 패스보다 불합리함. 그래도 싱글보단 메모리를 덜 차지하기 때문에 무조건 싱글만 쓰진 않음.
최신 버전에선 일반적으로 싱글 패스 방식 사용.
다음의 경우 싱글 패스 사용 못하고 투 패스 사용
1. 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
2. BLOB, TEXT 타입의 컬럼이 select 대상에 포함될 때
--> 2의 경우 메모리가 매우 크기 때문에 빼고하는게 효율적인듯
싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적
select 쿼리에서 꼭 필요한 컬럼만 조회하는게 아닌 모든 컬럼(*)을 가져오도록 하는 경우가 있는데, 이는 정렬 버퍼를 몇 배에서 몇십 배까지 비효율적으로 사용할 가능성 크다.
꼭 필요한 컬럼만 작성하는게 좋음. 이는 꼭 정렬 버퍼에만 영향을 미치는 것이 아니라 임시 테이블이 필요한 쿼리에서도 영향을 미친다.
--> 머리속에 잘 새기자

정렬 처리 방법
쿼리에 order by가 사용되면 반드시 아래 3가지 방법 중 하나로 처리. 아래로 갈수록 처리 속도 떨어짐.
1. 인덱스 사용 정렬   실행 계획에 별도 표기 없음.
2. join에서 드라이빙 테이블(드라이빙 테이블 : 먼저 접근되는 테이블.)만 정렬  실행계획에 Using filesort 표시.
3. join에서 join 결과를 임시 테이블로 저장 후 정렬   실행계획에 Using temporary; Using filesort 표시.
--> 3번은 2번보다 결과가 많아질 수 있기 때문에 2번이 효율적

인덱스를 이용한 정렬
order by에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, order by 순서대로 생성된 인덱스가 있어야함.
또한 where절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 order by는 같은 인덱스를 사용해야함.
ex) where user.age > 20 order by user.age desc      user index age
B-Tree 계열의 인덱스가 아닌 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬 사용 못함.
--> 해시 인덱스 : 해시 테이블에서 정렬 가능? NO
여러 테이블이 조인되는 경우는 nested-loop(다중 for문)방식의 조인에서만 인덱스 정렬 가능.
--> nested-loop의 드라이빙 테이블에서 순서대로 읽는게 곧 정렬 순이다.
ex) 
select *
from product p
join product_status_type pst on p.id = pst.product_id
order by p.name
index product name 
이라면
product가 드라이빙 테이블이 되고 product는 name으로 정렬된 인덱스가 있기 때문에
해당 인덱스의 순서대로 접근하면서 product_status_type 테이블과 join을 하게 된다.
--> nested-loop가 아닌 hash-join에서는 인덱스를 이용한 정렬이 안될까?
도큐먼트를 보니 hash-join을 이용할 때 조건 중 하나가 사용 가능한 인덱스가 없을 경우라고 적혀있다.
그러니 인덱스를 이용한 정렬도 안될듯?
인덱스의 순서대로 읽기만 하면 될 뿐이니 MySQL 엔진에서 별도의 정렬을 위한 추가 작업 하지 않는다.
order by가 있든 없든 결과는 같다. 그래도 order by는 적어주는게 좋다.
그 이유는 어떠한 이유로 인해 실행 계획이 조금 변경되면 order by가 없어서 잘못된 결과가 나올 수 있다.
--> 실행 계획이 변경돼서 다른 인덱스를 타면 정렬 결과가 달라질 수 있음!
--> order by 적는다고 부하가 더 생기는게 아님. 적나 안적나 실헹 과정은 완전 동일! 그러니까 적어주자.
join이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

조인의 드라이빙 테이블만 정렬
일반적으로 조인이 수행되면 레코드의 건수가 많이 늘어남. 레코드 하나하나의 크기도 늘어남. 그래서 조인을 실행하기전에 드라이빙 테이블의 정렬을 수행한 다음 조인을 하는 방법도 있음.
이 방법으로 정렬이 되려면 드라이빙 테이블의 컬럼만으로 order by 절을 작성해야함.
ex) 
select *
from product p 
join product_status ps
on p.id = ps.product_id
where p.id between 1 and 100
order by p.name

index product_status product_id
이 예제는 order by p.name에 의해 인덱스 정렬이 불가능한 상태이다.
--> 쿼리를 잠깐 봤을 땐 p.id between 1 and 100에 포함되는 값을 product_status와 조인 후 나온 결과를 name으로 정렬할 느낌이다.
하지만 실제 결과는
1. p.id between 1 and 100에 포함되는 값을 인덱스를 통해 빠르게 구한다.
2. 1의 결과를 name으로 정렬한다.(filesort)
3. 2의 결과와 product_status를 product_status의 인덱스를 통해서 빠르게 조인한다.

임시 테이블을 이용한 정렬
2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시테이블이 필요할 수 있다.
위의 정렬에 정렬해야할 레코드가 많아서 느림.
ex)
select *
from product p
join product_status ps
on p.id = ps.product_id
where p.id between 1 and 100
order by ps.code

index product_status product_id
이 예제는 위와 비슷하지만 order by만 다름. 정렬 기준이 드리븐 테이블에 있기 떄문에 조인 결과로 정렬할 수 밖에 없음. 고로 임시 테이블에 올려야 한다.

정렬 처리 방법의 성능 비교
주로 웹 서비스용 쿼리에서는 order by와 함께 limit이 거의 필수로 사용되는 경향이 있음.
--> 페이지네이션
일반적으로 limit은 테이블이나 처리 결과의 일부만 가져오기 때문에 mysql 서버가 할 작업량을 줄임.
order by나 group by 같은 작업은 where 조건으로 처리한 레코드를 limit 건수만큼만 가져와서 처리할 수 없다.
--> where처리 후 order by, group by 작업을 해야하기 때문임.

스트리밍 방식
서버 쪽에서 처리할 데이터가 얼마인지 관계없이 조건에 일치하는 레코드가 검색될때마다 클라이언트로 전송해주는 방식.
이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리 쏘고 곧바로 원하는 데이터를 받는다. 물론 마지막 데이터는 언제 받을지 모름.(그다지 중요하지 않음)
--> 뭔가 영상 스트리밍 느낌.
--> 한번에 받는 방식이 아니기 때문에 뭔가 느낌이 커넥션을 계속 잡을 느낌. 그리고 찾는 족족 보낸다고 했으니까 네트워크 부하가 심할수도 있겠다.
클라이언트는 서버로부터 일치하는 데이터를 즉시 받을 수 있기 때문에 데이터 가공 작업 가능하다.
웹 서비스 같은 OLTP 환경에서는 쿼리의 요청부터 첫 번째 레코드 받기까지의 응답시간 중요. 쿼리가 많아도 빠른 응답 시간 보장.
스트리밍 + LIMIT은 실행 시간을 많이 줄여줌.

버퍼링 방식
order by, group by 같은 쿼리는 스트리밍 되는 것을 불가능하게 함.
--> 조회 + 추가 작업인데 추가 작업을 할 때 모든 조회 결과가 필요하므로 스트리밍 안되는 듯 함.
버퍼링 + LIMIT은 크게 도움이 되지 않는다. 네트워크로 전송되는 레코드의 건수는 줄일 수 있지만, MySQL 서버가 해야하는 작업은 변함 없음.







