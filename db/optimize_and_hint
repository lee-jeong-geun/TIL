MySQL의 쿼리를 최적으로 실행 하도록 계획을 수립하는게 옵티마이저다.
실행 계획을 통해서 확인하자.

쿼리 실행 절차.
1. 주어진 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해 가능하도록 분리(파스 트리)한다.
2. SQL의 파싱 정보를 확인하면서 어떻게 실행할지(어떤 테이블 읽고 어떤 인덱스 선택할지) 선택한다.
3. 2번에서 결정된 실행을 통해 스토리지 엔진으로부터 데이터 가져온다.

2번 단계에서 다음과 같은 내용 처리
1. 불필요한 조건 제거 및 연산의 단순화
2. 여러 테이블의 조인 순서를 선택
--> 순서에 따라서 걸러지는 데이터 차이가 큼
3. 각 테이블에 사용된 조건과 통계정보를 활용해 인덱스 선택
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
5. 그 외에 더 있음

옵티 마이저 종류
1. 비용 기반 최적화
--> 쿼리를 처리하기 위한 여러 가지 방법을 만들고 각 방법의 비용을 계산해서 선택, 통계 정보 활용함
2. 규칙 기반 최적화
--> 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립. 휴리스틱하기 때문에 잘 안씀

풀 테이블 스캔하는 주된 이유
1. 레코드 건수 자체가 너무 작아서 인덱스 읽는 것보다 풀 테이블 스캔하는게 더 빠른 경우(테이블이 1개의 페이지로 구성된 경우)
--> 세컨더리 인덱스 -> 클러스터드 인덱스 -> 테이블 접근 보다   해당 페이지 1개를 바로 읽는게 훨씬 빠름.
2. where, on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
3. 인덱스 레인지 스캔 가능해도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)



InnoDB에서는 특정 테이블의 연속된 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
리드 어헤드 작업이란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 저장함
캐시 라인 처럼 한 번에 여러개의 페이지를 읽음. 최대 64개.
리드 어헤드는 풀 테이블 스캔에만 사용되는게 아니라 풀 인덱스 스캔에서도 이용됨.


병렬 처리
하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리함.
MySQL 8.0에서는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능.
아무리 병렬 처리 스레드 개수를 늘려도 서버의 CPU 코어 개수를 넘어서면 오히려 성능이 떨어질 수 있음.


ORDER BY 처리(Using filesort)
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
인덱스 장점
insert, update, delete 쿼리 실행시 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠름.
인덱스 단점
insert, update, delete 작업 시 부가적인 인덱스 추가/삭제 작업 필요하므로 느림.(B-Tree 특성임)
인덱스 떄문에 디스크 공간 더 많이 필요
--> 당연히 메모리에만 올리고 끝이 아니라 디스크에 저장 후 메모리에 불러오기 떄문에 저장 공간 필요
인덱스의 개수 늘어날수록 버퍼 풀을 위한 메모리 많이 필요.
Filesort 장점
인덱스 생성 안해도 됨. 정렬해야 할 레코드가 많이 않으면 메모리에서 처리 되므로 빠르다.
Filesort 단점
정렬 작업이 쿼리 실행 시 처리되므로 레코드가 많아질수록 느려짐.




















