클러스터링 인덱스란?
인덱스의 순서 자체가 실제 물리 저장소에서 동일한 순서임
즉 인덱스상 순서로 1, 2, 3, 4, 5 .... 가 물리 저장소에서 연속으로 저장되는 것
이것의 이점은 물리적으로 연속되어있다(지역성) 보니 한번에 퍼올려서 조회가 가능하다. 즉 disk i/o가 줄어들 수 있다.
이러한 이점을 통해서 테이블 풀 스캔이 인덱스 풀 스캔보다 무조건 빠르진 않지만, 빨라질 수 있다.
물리 저장소에 저장되다 보니 되도록이면 클러스터링 인덱스는 수정하지 않는게 좋다.
---> 추가적인 고민 : 1 ~ 1000만 까지의 클러스터링 인덱스가 있고 중간에 데이터를 삽입한다면 어떻게 될까?
---> 페이지 단위로 저장되는 db 특성상 분명히 삽입 위치의 페이지는 꽉 차 있을 것이다. 그러면 다음 페이지들을 한칸씩 뒤로 땡길까?

mysql innodb에서는 pk가 없을 경우 다음 우선 순위로 클러스터링 키 선택
1. pk가 있다면 해당 pk를 선택
2. not null 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 선택

고로 pk를 만들지 않아도 innodb 자체적으로 클러스터링을 구성하는 키 생성. 가능하다면 pk를 명시적으로 생성하는게 좋다.

innodb에서는 세컨더리 인덱스에서 키값을 조회하고 해당 키값의 pk를 클러스터링 인덱스에서 다시 한번 조회 후 실제 데이터로 접근하는 방식을 가진다.
왜? 세컨더리 인덱스에서는 바로 데이터를 접근 안하도록 했을까? 
--> 세컨더리에서 바로 데이터를 조회하도록 했으면 해당 데이터의 클러스터링 키가 바뀔 경우 실제 주소도 바뀌기 때문에 테이블의 세컨더리 인덱스를 모두 갱신해주어야 한다. 이러한 오버헤드를 줄이기 위해
innodb에서는 실제 데이터 접근을 클러스터링 인덱스를 통해 하도록 했다.
--> 클러스터링 인덱스가 1, 2, 5, 9, 15로 되어있을 때 7을 삽입한다고 하면 1, 2, 7, 9, 15가 되므로 9, 15의 실제 주소가 변경된다. 세컨더리 인덱스에서 주소를 직접 참조하고 있으면 갱신 해줘야 하고,
그게 아니라 pk를 통해 주소 접근이라면 pk는 그대로이기 때문에 세컨더리 인덱스는 수정할게 없다.

클러스터링 인덱스의 장, 단점
장점
1. pk로 검색할 때 매우 빠름(특히 범위 검색일 경우 매우 빠름) -> 지역성을 통해서 얻는 이득 같음
2. 모든 세컨더리 인덱스는 프라이 머리 키를 가지고 있기 때문에 인덱스 자체(커버링 인덱스)만으로 쿼리를 처리 가능 
-> 실제 데이터를 접근 하지 않는 이득
-> disk i/o를 줄 일 수 있다. 물론 해당 페이지가 버퍼풀에 올라온 경우라면 메모리상으로 처리가능. 하지만 실제 데이터를 퍼 올리는 경우 많은 메모리가 필요하기 떄문에 비교적 작은 인덱스만을 메모리에 올리는게
더 좋음

단점
1. 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키가 많을 경우 세컨더리 인덱스 몸집이 커진다.
2. 세컨더리 -> pk -> 실제 데이터 순으로 검색하기 때문에 느림
3. 데이터 삽입 시 pk에 의해 레코드 위치 결정되므로 느림
4. pk 변경시 레코드를 삭제하고 삽입하는 작업이 필요하므로 느림 -> pk 변경 최소화 하자...

고로 클러스터링 인덱스는 읽기에 강점이 있고 삽입, 갱신, 삭제에 약점이 있다. 일반적으로 웹 서비스 같은 OLTP 환경에서는 쓰기와 읽기 비율이 2:8 or 1:9정도 되므로 클러스터링 인덱스가 좋다.

클러스터링 인덱스 사용시 주의 사항
1. 클러스터링 인덱스 크기
--> 보통 세컨더리 인덱스 5개 정도 생성. pk 크기 * 인덱스 개수 * 레코드 개수 ==> 인덱스 개수, 레코드 개수는 동일하다 했을 때 pk 크기로 인해 메모리 증가
2. pk는 반드시 명시할 것
--> innodb는 pk가 없을 경우 자동으로 생성해줌. 하지만 자동생성된 pk는 사용자 입장에서 보이지 않으므로 사용 불가...

유니크 인덱스
유니크는 인덱스 없이 유니크 제약을 걸 수 없다. null은 저장된다. null은 특정 값이 아니라 2개 이상 저장 가능.

유니크 인덱스와 일반 세컨더리 인덱스는 구조가 같다.
유니크 인덱스가 빠르다고 생각하지만 사실이 아니다. 유니크하지 않은 세컨더리 인덱스는 중복값 허용으로 인한 읽어야 할 데이터가 많아서 유니크 인덱스보다 느린 것일 뿐 인덱스 특성의 차이로 인한 느림이 아님.
세컨더리 인덱스에서 유니크 인덱스 보다 더 해야하는 작업은 디스크 i/o가 아니라 cpu에서 컬럼값 비교하는 것이라 성능상 영향이 거의 없음.

유니크 인덱스 쓰기는 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 필요. 그래서 세컨더리 인덱스보다 느림.
innodb에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼 사용. 그래서 인덱스의 저장, 변경 작업은 빠르게 처리. 하지만 유니크 인덱스는 중복 체크를 해야 하므로 작업 자체를 버퍼링 못함.

유니크 인덱스 사용시 주의 사항
같은 컬럼에 대해 유니크 인덱스, 일반 인덱스 생성하는 건 의미 없음(pk와 유니크 인덱스도 마찬가지)

유일성을 꼭 보장해야하는 컬럼이라면 유니크 인덱스를 생성하되, 그렇지 않다면 세컨더리 인덱스를 생성하는 것을 고려해보기.

외래키
MySQL에서 외래키는 InnoDB만 생성 가능.
외래키 제약 설정시 연관되는 테이블의 칼럼에 인덱스 생성됨. 외래키 제거x시 자동으로 생성된 인덱스 삭제 불가.
--> 자동으로 생성이라는 것을 보면 세컨더리 인덱스로 생성 되는듯(pk라면 이미 생성되어 있기 때문)
innoDB의 외래키 관리 특징
1. 
1) 부모 테이블(외래키 컬럼 제공)에서 쓰기 락이 걸려있으면 자식 테이블에선 부모 테이블의 쓰기 락이 해제될 때까지 변경하는 것을 기다리게 된다.
자식 테이블에서 외래키 컬럼의 변경이 발생되면 부모 테이블을 확인한다. 부모 테이블이 쓰기 락이 걸려있다면 자식 테이블은 기다린다.
--> 자식 테이블이 빈번하게 변경이 발생될 경우 부모 테이블의 데이터를 바꾸면 자식쪽에 생기는 락은 볼만하겠다.
ex) 게시글과 댓글의 관계
1개의 인기 게시글이 있을 때 이용자 1만명이 댓글을 동시에 달려고 한다.
이때 인기 게시글의 주인은 글을 잘못 올린 것 같아서 내용의 대부분을 수정했다(약 50만자 가량 수정)
수정된 내용이 크다보니 해당 글은 장시간 쓰기락을 걸어버리게 되고, 이용자 1만명이 댓글을 달았지만 게시글이 쓰기락 걸린 상태라 댓글들이 보이지가 않는 상황이 발생...
만약 게시글과 댓글이 외래키 관계가 아니였다면 스무스하게 댓글도 달리고 게시글도 수정됐을 것이다.
이래서 외래키를 잘안쓰는건가??

2) 자식 테이블에서 쓰기 락이 걸릴 때 부모 테이블에서 변경을 한다면 자식 테이블의 쓰기 락이 해제될 때까지 기다리게 된다.
이 경우의 예시는 on delete cascade 걸린 상태에서 자식 테이블의 변경 작업 후 커밋을 하기 전에 부모 테이블에서 해당 row를 delete하면 자식 테이블의 쓰기 락이 해제될 때까지 기다린다.
자식 테이블 <> 부모 테이블 서로서로 락이 걸리는 구조다.

2. 자식 테이블의 외래키 컬럼이 아닌 컬럼의 변경은 부모 테이블을 확인하지 않는다.


외래 키를 물리적으로 생성하려면 잠금 경합까지 고려해서 모델링을 하는 것이 좋다.
자식 테이블에 레코드가 추가되는 경우 부모 테이블에 참조키가 있는지 확인하게 되는데, 이때 체크만 하는 것이 아니라 락을 걸게 된다.
이렇게 다른 테이블로 확장되면 전체적으로 쿼리의 동시 처리에 영향을 미치게 되므로 잠금 경합을 잘 고려해야한다.








