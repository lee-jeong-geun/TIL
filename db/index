클러스터링 인덱스란?
인덱스의 순서 자체가 실제 물리 저장소에서 동일한 순서임
즉 인덱스상 순서로 1, 2, 3, 4, 5 .... 가 물리 저장소에서 연속으로 저장되는 것
이것의 이점은 물리적으로 연속되어있다(지역성) 보니 한번에 퍼올려서 조회가 가능하다. 즉 disk i/o가 줄어들 수 있다.
이러한 이점을 통해서 테이블 풀 스캔이 인덱스 풀 스캔보다 무조건 빠르진 않지만, 빨라질 수 있다.
물리 저장소에 저장되다 보니 되도록이면 클러스터링 인덱스는 수정하지 않는게 좋다.
---> 추가적인 고민 : 1 ~ 1000만 까지의 클러스터링 인덱스가 있고 중간에 데이터를 삽입한다면 어떻게 될까?
---> 페이지 단위로 저장되는 db 특성상 분명히 삽입 위치의 페이지는 꽉 차 있을 것이다. 그러면 다음 페이지들을 한칸씩 뒤로 땡길까?

mysql innodb에서는 pk가 없을 경우 다음 우선 순위로 클러스터링 키 선택
1. pk가 있다면 해당 pk를 선택
2. not null 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 선택

고로 pk를 만들지 않아도 innodb 자체적으로 클러스터링을 구성하는 키 생성. 가능하다면 pk를 명시적으로 생성하는게 좋다.

innodb에서는 세컨더리 인덱스에서 키값을 조회하고 해당 키값의 pk를 클러스터링 인덱스에서 다시 한번 조회 후 실제 데이터로 접근하는 방식을 가진다.
왜? 세컨더리 인덱스에서는 바로 데이터를 접근 안하도록 했을까? 
--> 세컨더리에서 바로 데이터를 조회하도록 했으면 해당 데이터의 클러스터링 키가 바뀔 경우 실제 주소도 바뀌기 때문에 테이블의 세컨더리 인덱스를 모두 갱신해주어야 한다. 이러한 오버헤드를 줄이기 위해
innodb에서는 실제 데이터 접근을 클러스터링 인덱스를 통해 하도록 했다.
--> 클러스터링 인덱스가 1, 2, 5, 9, 15로 되어있을 때 7을 삽입한다고 하면 1, 2, 7, 9, 15가 되므로 9, 15의 실제 주소가 변경된다. 세컨더리 인덱스에서 주소를 직접 참조하고 있으면 갱신 해줘야 하고,
그게 아니라 pk를 통해 주소 접근이라면 pk는 그대로이기 때문에 세컨더리 인덱스는 수정할게 없다.

클러스터링 인덱스의 장, 단점
장점
1. pk로 검색할 때 매우 빠름(특히 범위 검색일 경우 매우 빠름) -> 지역성을 통해서 얻는 이득 같음
2. 모든 세컨더리 인덱스는 프라이 머리 키를 가지고 있기 때문에 인덱스 자체(커버링 인덱스)만으로 쿼리를 처리 가능 
-> 실제 데이터를 접근 하지 않는 이득
-> disk i/o를 줄 일 수 있다. 물론 해당 페이지가 버퍼풀에 올라온 경우라면 메모리상으로 처리가능. 하지만 실제 데이터를 퍼 올리는 경우 많은 메모리가 필요하기 떄문에 비교적 작은 인덱스만을 메모리에 올리는게
더 좋음

단점
1. 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키가 많을 경우 세컨더리 인덱스 몸집이 커진다.
2. 세컨더리 -> pk -> 실제 데이터 순으로 검색하기 때문에 느림
3. 데이터 삽입 시 pk에 의해 레코드 위치 결정되므로 느림
4. pk 변경시 레코드를 삭제하고 삽입하는 작업이 필요하므로 느림 -> pk 변경 최소화 하자...

고로 클러스터링 인덱스는 읽기에 강점이 있고 삽입, 갱신, 삭제에 약점이 있다. 일반적으로 웹 서비스 같은 OLTP 환경에서는 쓰기와 읽기 비율이 2:8 or 1:9정도 되므로 클러스터링 인덱스가 좋다.

클러스터링 인덱스 사용시 주의 사항
1. 클러스터링 인덱스 크기
--> 보통 세컨더리 인덱스 5개 정도 생성. pk 크기 * 인덱스 개수 * 레코드 개수 ==> 인덱스 개수, 레코드 개수는 동일하다 했을 때 pk 크기로 인해 메모리 증가
2. pk는 반드시 명시할 것
--> innodb는 pk가 없을 경우 자동으로 생성해줌. 하지만 자동생성된 pk는 사용자 입장에서 보이지 않으므로 사용 불가...

유니크 인덱스
유니크는 인덱스 없이 유니크 제약을 걸 수 없다. null은 저장된다. null은 특정 값이 아니라 2개 이상 저장 가능.

유니크 인덱스와 일반 세컨더리 인덱스는 구조가 같다.
유니크 인덱스가 빠르다고 생각하지만 사실이 아니다. 유니크하지 않은 세컨더리 인덱스는 중복값 허용으로 인한 읽어야 할 데이터가 많아서 유니크 인덱스보다 느린 것일 뿐 인덱스 특성의 차이로 인한 느림이 아님.
세컨더리 인덱스에서 유니크 인덱스 보다 더 해야하는 작업은 디스크 i/o가 아니라 cpu에서 컬럼값 비교하는 것이라 성능상 영향이 거의 없음.

유니크 인덱스 쓰기는 키 값을 쓸 때 중복된 값이 있는지 없는지 체크하는 과정이 필요. 그래서 세컨더리 인덱스보다 느림.
innodb에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼 사용. 그래서 인덱스의 저장, 변경 작업은 빠르게 처리. 하지만 유니크 인덱스는 중복 체크를 해야 하므로 작업 자체를 버퍼링 못함.

유니크 인덱스 사용시 주의 사항
같은 컬럼에 대해 유니크 인덱스, 일반 인덱스 생성하는 건 의미 없음(pk와 유니크 인덱스도 마찬가지)

유일성을 꼭 보장해야하는 컬럼이라면 유니크 인덱스를 생성하되, 그렇지 않다면 세컨더리 인덱스를 생성하는 것을 고려해보기.








